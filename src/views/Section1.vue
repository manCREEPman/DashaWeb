<template>
    <v-card
    class="px-5">
    <v-card-title>
        Введение в Flask
    </v-card-title>
    <p>
        <span class="bold-header">
            Почему Flask называют «микрофреймоворком»?
        </span>
        Flask – микрофреймоворк для создания web-приложений на Python. Приставка «микро» используется для обозначения, что Flask предоставляет лишь самые базовые функции web-фреймоворка, позволяющие быстро запустить рабочее приложение, при этом имея возможность нарастить «каркас» его архитектуры за счёт расширений Flask. Например, расширение Flask Alchemy для работы с базами данных или Flask Login для добавления обычной рутины сессионных авторизаций. О них, к слову, я расскажу подробнее далее.

    </p>
    <p>
        <span class="bold-header">

            На чём основывается Flask?
        </span>
        Flask построен на библиотеке Werkzueg (Веркцайг) – комплексной библиотеке для поддержки WSGI (Web Server Gateway Interface) приложений и шаблонизаторе Jinja2 (отличается от шаблонизатора Django тем, что позволяет вызывать функции с аргументами на объектах)
    </p>
    <p>
        <span class="bold-header">
            
            Установка
        </span>
        <pre>
    Для установки Flask необходимо вызвать команду менеджера пакетов Python pip: pip install flask
        </pre>
    </p>
    <p>
        <span class="bold-header">
            
            Простейшая программа
        </span>
        Для создания простейшей программы необходимо: импортировать класс Flask и получить экземпляр нашего приложения через вызов его конструктора.
        Далее мы создаём экземпляр этого класса. Первый аргумент — это имя модуля или пакета приложения. Если мы используем единственный модуль, нам следует использовать __name__, потому что в зависимости от того, запущен ли код как приложение, или импортирован как модуль, это имя будет разным ('__main__' или актуальное имя импортированного модуля соответственно). Это нужно, чтобы Flask знал, где искать шаблоны, статические файлы и прочее.
        Далее, мы используем декоратор route(), чтобы сказать Flask, какой из URL должен запускать нашу функцию.
        Функция, которой дано имя, используемое также для генерации URL-адресов для этой конкретной функции, возвращает сообщение, которое мы хотим отобразить в браузере пользователя.
        Наконец, для запуска локального сервера с нашим приложением, мы используем функцию run(). Благодаря конструкции if __name__ == '__main__' можно быть уверенным, что сервер запустится только при непосредственном вызове скрипта из интерпретатора Python, а не при его импортировании в качестве модуля.

    </p>   
    <p>
        <span class="bold-header">
            
            Дополнительные поля конструктора класса Flask
        </span>
        import_name – имя пакета приложения <br>
        static_url_path – может быть использован для задания другого пути для статичных файлов в сети. По умолчанию отсылает на имя папки, задаваемое параметром static_folder.
<br>
static_folder – папка со статическими файлами, обслуживаемыми по static_url_path. По умолчанию 'static' – папка в корне приложения.
<br>
template_folder – папка, содержащая шаблоны, используемые приложением. По умолчанию 'templates' – папка в корне приложения.
<br>
instance_path – альтернативный путь к экземпляру приложения. По умолчанию - папка 'instance'. Предполагается, что путь к экземпляру находится рядом с пакетом или модулем приложения.
<br>
instance_relative_config – если установлен в True, то предполагается, что относительные имена файлов для загрузки конфигурации относятся к пути экземпляра, а не к корню приложения.
<br>

    </p>
    <p>
        <span class="bold-header">
            
            Дополнительные параметры функции run
        </span>
        host – Прослушиваемый хост. Установите для этого значение '0.0.0.0', чтобы сервер также был доступен извне. Значение по умолчанию равно '127.0.0.1'.
        <br>
        port – порт сервера. по умолчанию 5000 или задаётся через SERVER_NAME в конфиге.
    <br>
    debug – активация/деактивация режима отладки.
    <br>
    options – параметры, которые будут перенаправлены на базовый сервер
<br>


    </p>
    <p>
        <span class="bold-header">
            
            Отрисовка шаблонов
        </span>
        Для отрисовки шаблонов необходимо вызвать функцию render_template. Она может принимать следующие параметры.
    <br>
    template_name_or_list – имя шаблона, который должен быть отображен, или перечислимый тип данных с именами шаблонов, который будет отображен первым из существующих.
<br>
context – переменные, которые будут доступны в контексте шаблона.
<br>

Flask использует шаблонизатор Jinja2.
    </p>
    <p>
        <span class="bold-header">
            
            Построение URL
        </span>
        Flask позволяет сделать определенные части URL динамически меняющимися и задействовать в функции несколько правил.
        <br>
        Правила для переменной части
<br>
Чтобы добавлять к адресу URL переменные части, можно эти особые части выделить как variable_name. Затем подобные части передаются в вашу функцию в качестве аргумента - в виде ключевого слова. Также может быть использован конвертер - с помощью задания правила следующего вида
<br>
Существуют следующие конвертеры:
<br>
int	принимаются целочисленные значения
<br>
float	как и int, только значения с плавающей точкой
<br>    
path	подобно поведению по умолчанию, но допускаются converter:variable_name. 
</p>

<p>
    <span class="bold-header">
        Построение (генерация) URL
            
        </span>
        Раз Flask может искать соответствия в URL, может ли он их генерировать? Конечно, да. Для построения URL для специфической функции, вы можете использовать функцию url_for(). В качестве первого аргумента она принимает имя функции, кроме того она принимает ряд именованных аргументов, каждый из которых соответствует переменной части правила для URL. Неизвестные переменные части добавляются к URL в качестве параметров запроса. Вот некоторые примеры:
        Для использования url_for в коде приложения необходимо передать контекст запроса. Сделать это можно с использованием метода test_request_context(). Он просит Flask вести себя так, как будто он обрабатывает запрос, даже если мы взаимодействуем с ним через оболочку Python.
        Есть 3 основные причины для генерации URL таким способом:
        <br>
        <ol>
            <li>
                По сравнению с жёстким заданием URL внутри кода обратный порядок часто является более наглядным. Более того, он позволяет менять URL за один шаг, и забыть про необходимость изменять URL повсюду. 

            </li>
            <li>
                Построение URL будет прозрачно для вас осуществлять экранирование специальных символов и данных Unicode, так что вам не придётся отдельно иметь с ними дела. 

            </li>
            <li>

                Если ваше приложение размещено не в корневой папке URL root (а, скажем, в /myapplication вместо /), данную ситуацию нужным для вас образом обработает функция url_for().
            </li>
        </ol>

        
    </p>

<p>
    <span class="bold-header">
        Методы HTTP (как список), контекст запроса/ответа
            
        </span>
        Прежде чем говорить про объекты запроса или ответа, надо сказать, что в каждую функцию-представление Flask можно передать список методов, который в ней будет обрабатываться. По умолчанию это просто GET.
        Итак объект запроса. Объект запроса это экземпляр подкласса Request, сопровождаемый всеми атрибутами, которые определены в Werkzeug.
        Flask занимается разбором данных поступившего запроса и предоставляет нам к ним доступ через глобальный объект. Внутри себя Flask проверяет, что в случае многопоточного окружения, мы всегда получим корректные данные, адресованные активному потоку.
        <br>
        form MultiDict с данными разбора от запросов POST или PUT. Помните, пожалуйста, что загрузки файлов на этом не ограничиваются, есть ещё атрибут files.
        <br>
        args MultiDict с разобранным содержимым строки запроса. (Это та часть URL, которая следует после знака вопроса).
        <br>
        values CombinedMultiDict с содержимым form и args.
        <br>
        cookies dict с содержимым всех переменных браузера, переданных с запросом.
        <br>
        stream Если поступающие данные формы не закодированы одним из известных типов mimetype, потребляемые данные сохраняются в этом потоке в неизменном виде. В большинстве случаев лучше использовать data, который предоставит вам эти данные в виде строки. Поток возвращает данные лишь единожды.
        headers Заголовки поступившего запроса в виде словаря, как объекта.
        <br>
        data Содержит данные поступившего запроса в виде строки в том случае, когда Flask не может обработать такой mimetype.
        <br>
        files MultiDict с файлами, загружаемыми как часть запроса POST или PUT. Каждый файл сохраняется в виде объекта FileStorage. Он, говоря простым языком, ведёт себя как известный нам по Python объект файла, с той разницей, что в нём есть функция save(), которая может сохранить файл в файловую систему.
        <br>
        environ Нижележащее WSGI-окружение.
        <br>
        method Текущий метод запроса (POST, GET и т. д.)
        <br>Помимо того есть несколько полей, описывающих текущий URL
Представим, что ваше приложение соответствует следующему URL:
http://www.example.com/myapplication
А запросы пользователя поступают на такой URL:
http://www.example.com/myapplication/page.html?x=y
В таком случае значения вышеупомянутых атрибутов станут как показано на слайде
    </p>

<p>
    <span class="bold-header">
        Ответы
            
        </span>

        Возвращаемое из функции представления значение автоматически для вас конвертируется вас в объект ответа. Если возвращаемое значение является строкой, оно конвертируется в объект ответа в строку в виде тела ответа, код статуса 200 OK и в mimetype со значением text/html. Логика, которую применяет Flask для конвертации возвращаемых значений в объекты ответа следующая:
        <ul>
            <li>

                Если возвращается объект ответа корректного типа, он прямо возвращается из представления.
            </li>
            <li>
                
                Если это строка, создаётся объект ответа с этими же данными и параметрами по умолчанию.
            </li>
            <li>
                Если возвращается кортеж, его элементы могут предоставлять дополнительную информацию. Такие кортежи должны соответствовать форме (ответ, статус, заголовки), кортеж должен содержать хотя бы один из перечисленных элементов. Значение статус заменит код статуса, а элемент заголовки может быть или списком или словарём с дополнительными значениями заголовка.

            </li>
            <li>

                Если ничего из перечисленного не совпало, Flask предполагает, что возвращаемое значение - это допустимая WSGI-заявка, и конвертирует его в объект ответа.
            </li>
            <li>
                
                Если вы хотите в результате ответа заполучить объект внутри представления, то можете использовать функцию make_response().
            </li>
        </ul>
        <br>
        По умолчанию Flask возвращает ответы в формате text/html. С помощью функции jsonify можно возвращать ответы в формате application/json, передавая в качестве параметра словарь с какими-либо данными
        
</p>
<p>
    <span class="bold-header">
            
        Ошибки и перенаправления
        </span>
        
        Чтобы перенаправить пользователя в иную конечную точку, используйте функцию redirect(); для того, чтобы преждевременно прервать запрос с кодом ошибки, используйте функцию abort() function:
        
        По умолчанию, для каждого кода ошибки отображается чёрно-белая страница с ошибкой. Если вы хотите видоизменить страницу с ошибкой, то можете использовать декоратор errorhandler(): Для этого необходимо указать соответствующий декоратор перед функцией-представлением с единственным аргументом.

</p>

<p>
    <span class="bold-header">
            
        Журналирование
        </span>
        Для вывода ошибок или отладочной информации можно использовать журналирование Flask. Для этого можно воспользоваться полем logger, который является экземпляром стандартного Python logger. Для отправки сообщений debug в конфиге приложения должен стоять флаг debug: True

</p>

<p>
    <span class="bold-header">
        Контрольные вопросы
            
        </span>
        <ol>
            <li>

            	Почему Flask – микрофреймворк?
            </li>
            <li>
                Как называется функция создания ответа в функции-представлении?

            </li>
            <li>

                С помощью какой функции можно вызывать отрисовку шаблона страницы?
            </li>
            <li>
            	Какой декоратор используется для представлений-обработчиков ошибок?

            </li>
            <li>
            	Какая функция позволяет возвращать ответы в формате application/json?

            </li>
        </ol>
</p>
<p>
    <span class="bold-header">
        Упражнения для самостоятельной работы
            
        </span>
        <ol>
            <li>
Создать представления для работы с ошибками или перенаправлениями.
<br>
<span class="bold-header">
    
    Решение.
</span>
В файле сделаем нужные импорты и допишем следующий код:
<pre>
    from flask import Flask, render_template, redirect, abort, url_for
    from pages_blueprint import page_views
    
    app = Flask(__name__)
    
    @app.route('/')
    def index():
        return redirect(url_for('picture'))
    
    @app.errorhandler(404)
    def error_handler(error):
        return 'Страницы не существует!', 404
    
    @app.route('/unknown')
    def unknown():
        abort(404)
    
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=1234)

</pre>
            </li>
            <li>
Создать вложенную структуру шаблонов страниц и подключить их к приложению. Главный шаблон, затем от него наследовать следующий шаблон, и от него наследовать конечную страницу.
            </li>
            <li>
Создать функцию-представление, которое возвращает ответ в формате application/json.
            </li>
        </ol>
</p>

    </v-card>
</template>

<script>
import Navigation from '@/components/Navigation.vue'

export default {
    name: 'Section1',
    components: {
        Navigation
    }
}
</script>