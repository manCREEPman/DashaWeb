<template>
    <v-card
    class="px-5">
        <v-card-title>
            Комплекс практических заданий для проверки умений и навыков
        </v-card-title>
        
        <p>
            <span class="bold-header">
                Задание №1.
            </span> Фильтрация уникальных элементов массива
            Допустим, у нас есть массив arr.
<br>
Создайте функцию unique(arr), которая вернёт массив уникальных, не повторяющихся значений массива arr.
<br>
Например:
<br><br>
<pre>
function unique(arr) {
  /* ваш код */
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(values) ); // Hare,Krishna,:-O
</pre>
<br>
P.S. Здесь мы используем строки, но значения могут быть любого типа.
<br>
P.P.S. Используйте Set для хранения уникальных значений.
</p>

        <p>
            <span class="bold-header">
                Задание №2.
            </span> Отфильтруйте анаграммы
            Анаграммы – это слова, у которых те же буквы в том же количестве, но они располагаются в другом порядке.
<br>
Например:
<br><br>
            <pre>
nap - pan
ear - are - era
cheaters - hectares - teachers
            </pre>
            <br>
            Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.
<br>
Например:
<br><br>
<pre>
let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) ); // "nap,teachers,ear" или "PAN,cheaters,era"
</pre>
<br>
Из каждой группы анаграмм должно остаться только одно слово, не важно какое.
        </p>
        <p>
            <span class="bold-header">
                Задание №3. 
            </span> Хранение отметок "не прочитано"
            <br>
            Есть массив сообщений:
            <br><br>
            <pre>
let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
            </pre>
            <br>
            У вас есть к ним доступ, но управление этим массивом происходит где-то ещё. Добавляются новые сообщения и удаляются старые, и вы не знаете в какой момент это может произойти.
<br>
Имея такую вводную информацию, решите, какую структуру данных вы могли бы использовать для ответа на вопрос «было ли сообщение прочитано?». Структура должна быть подходящей, чтобы можно было однозначно сказать, было ли прочитано это сообщение для каждого объекта сообщения.
<br>
P.S. Когда сообщение удаляется из массива messages, оно должно также исчезать из структуры данных.
<br>
P.P.S. Нам не следует модифицировать сами объекты сообщений, добавлять туда свойства. Если сообщения принадлежат какому-то другому коду, то это может привести к плохим последствиям.
        </p>
        <p>
            <span class="bold-header">
                Категории оценки:
            </span>
            <ol>
                <li>
                    
                    Полнота выполнения пунктов ТЗ;
                </li>
                <li>
                    Корректность работы написанной программы

                </li>
                <li>
                    Осмысленность использования инструментов для создания тех или иных объектов программы;

                </li>
                <li>

                    Обработка разнообразных исключений;
                </li>
            </ol>
        </p>
    </v-card>
</template>

<script>
export default {
    name: 'Tasks'
}
</script>