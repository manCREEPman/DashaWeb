<template>
    <v-card
    class="px-5">
        <v-card-title>
            
            Базы данных, таблицы, наполнение таблиц, простые запросы, изменение и удаление данных.  Соединения и подзапросы, группировки и сортировки
        </v-card-title>
        <p>
            <span class="bold-header">
        
                База данных
    </span>
    Давайте создадим новую базу данных с именем test. Выполните:
    <pre>
    postgres=# CREATE DATABASE test;
    CREATE DATABASE
    </pre>
    Не забудьте про точку с запятой в конце команды — пока PostgreSQL не увидит этот символ, он будет считать, что вы продолжаете ввод (так что команду можно разбить на несколько строк). Теперь переключимся на созданную базу:
    <pre>
    postgres=# \c test
    You are now connected to database "test" as user "postgres".
    test=#
    </pre>        
    Как вы видите, приглашение сменилось на test=#. 
    Команда, которую мы только что ввели, не похожа на SQL — она начинается с обратной косой черты. Так выглядят специальные команды, которые понимает только psql (поэтому, если у вас открыт pgAdmin или другое графическое средство, пропускайте все, что начинается на косую черту, или попытайтесь найти аналог).
    Полный список с кратким описанием можно получить прямо сейчас:
    <pre>
    test=# \?
    </pre>

    Поскольку справочная информация довольна объемна, она будет показана с помощью настроенной в операционной системе команды-пейджера (обычно more или less).
</p>
<p>
    <span class="bold-header">
        
        Таблицы 
    </span>
    
    В реляционных СУБД данные представляются в виде таблиц. Заголовок таблицы определяет столбцы; собственно данные располагаются в строках. Данные не упорядочены (в частности, нельзя полагаться на то, что строки хранятся в порядке их добавления в таблицу). Для каждого столбца устанавливается тип данных; значения соответствующих полей строк должны удовлетворять этим типам. PostgreSQL располагает большим числом встроенных типов (postgrespro.ru/doc/datatype) и возможностями для создания новых, но мы ограничимся несколькими из основных: 
    <ul>
        <li>
            integer — целые числа;

        </li>
        <li>

            text — текстовые строки; 
        </li>
        <li>

            boolean — логический тип, принимающий значения true (истина) или false (ложь). Помимо обычных значений, определяемых типом данных, поле может иметь неопределенное значение NULL — его можно рассматривать как «значение неизвестно» или «значение не задано».
        </li>
    </ul>
    Давайте создадим таблицу дисциплин, читаемых в вузе:
    <pre>
    test=# CREATE TABLE courses(
    test(# c_no text PRIMARY KEY,
    test(# title text,
    test(# hours integer
    test(# );
    CREATE TABLE
    </pre>
    
    Обратите внимание, как меняется приглашение psql: это подсказка, что ввод команды продолжается на новой строке. В дальнейшем для удобства мы не будем дублировать приглашение на каждой строке. 
    В этой команде мы определили, что таблица с именем courses будет состоять из трех столбцов: c_no — текстовый номер курса, title — название курса, и hours — целое число лекционных часов. 
    Кроме столбцов и типов данных мы можем определить ограничения целостности, которые будут автоматически проверяться — СУБД не допустит появление в базе некорректных данных. В нашем примере мы добавили ограничение PRIMARY KEY для столбца c_no, которое говорит о том, что значения в этом столбце должны быть уникальными, а неопределенные значения не допускаются. Такой столбец можно использовать для того, чтобы отличить одну строку в таблице от других. 
    Точный синтаксис команды CREATE TABLE можно посмотреть в документации, а можно прямо в psql:    
    <pre>
        test=# \help CREATE TABLE
    </pre>
    Такая справка есть по каждой команде SQL, а полный список команд покажет \help без параметров.
</p>
<p>
    <span class="bold-header">
        
        Наполнение таблиц
    </span>
    Добавим в созданную таблицу несколько строк:
    <pre>
        test=# INSERT INTO courses(c_no, title, hours)
        VALUES ('CS301', 'Базы данных', 30),
        ('CS305', 'Сети ЭВМ', 60);
        INSERT 0 2
    </pre>

    Если вам требуется массовая загрузка данных из внешнего
    источника, команда INSERT — не лучший выбор; для этого используется команда COPY.
    Для дальнейших примеров нам потребуется еще две таблицы: студенты и экзамены. Для каждого студента будем хранить его имя и год поступления; идентифицироваться он будет числовым номером студенческого билета.
    <pre>
        test=# CREATE TABLE students(
        s_id integer PRIMARY KEY,
        name text,
        start_year integer
        );
        CREATE TABLE
        test=# INSERT INTO students(s_id, name, start_year)
        VALUES (1451, 'Анна', 2014),
        (1432, 'Виктор', 2014),
        (1556, 'Нина', 2015);
        INSERT 0 3
    </pre>
    Экзамен содержит оценку, полученную студентом по некоторой дисциплине. Таким образом, студенты и дисциплины связаны друг с другом отношением «многие ко многим»: один студент может сдавать экзамены по многим дисциплинам, а экзамен по одной дисциплине могут сдавать много
    студентов.
    Запись в таблице экзаменов идентифицируется совокупностью номера студбилета и номера курса. Такое ограничение целостности, относящее сразу к нескольким столбцам, определяется с помощью фразы CONSTRAINT
    <pre>
    test=# CREATE TABLE exams(
    s_id integer REFERENCES students(s_id),
    c_no text REFERENCES courses(c_no),
    score integer,
    CONSTRAINT pk PRIMARY KEY(s_id, c_no)
    );
    CREATE TABLE
    </pre>

</p>
<p>
    Кроме того, с помощью фразы REFERENCES мы определили два ограничения ссылочной целостности, называемые внешними ключами. Такие ограничения показывают, что значения в одной таблице ссылаются на строки в другой таблице. 
    Теперь при любых действиях СУБД будет проверять, что все идентификаторы s_id, указанные в таблице экзаменов, соответствуют реальным студентам (то есть записям в таблице студентов), а номера c_no — реальным курсам. Таким образом, будет исключена возможность оценить несуществующего студента или поставить оценку по несуществующей дисциплине — независимо от действий пользователя или возможных ошибок в приложении.
    Поставим нашим студентам несколько оценок:
    <pre>
    test=# INSERT INTO exams(s_id, c_no, score)
    VALUES (1451, 'CS301', 5),
    (1556, 'CS301', 5),
    (1451, 'CS305', 5),
    (1432, 'CS305', 4);
    INSERT 0 4
    </pre>    
</p>
<p>
    <span class="bold-header">
        
        Выборка данных. Простые запросы
    </span>
    Чтение данных из таблиц выполняется оператором SQL SELECT. Например, выведем только два столбца из таблицы courses:
    <pre>
    test=# SELECT title AS course_title, hours
    FROM courses;
    </pre>
    <v-img src="@/assets/9.png"></v-img>
    Конструкция AS позволяет переименовать столбец, если это необходимо. Чтобы вывести все столбцы, достаточно указать символ звездочки:
    <pre>
    test=# SELECT * FROM courses;
    </pre>
    <v-img src="@/assets/10.png"></v-img>

    В результирующей выборке мы можем получить несколько одинаковых строк. Даже если все строки были различны в исходной таблице, дубликаты могут появиться, если выводятся не все столбцы:
    <pre>
    test=# SELECT start_year FROM students;
    </pre>
    <v-img src="@/assets/11.png"></v-img>

    Чтобы выбрать все различные года поступления, после SELECT надо добавить слово DISTINCT:
    <pre>
    test=# SELECT DISTINCT start_year FROM students;
    </pre>
    <v-img src="@/assets/12.png"></v-img>
    Вообще после слова SELECT можно указывать и любые выражения. А без фразы FROM результирующая таблица будет содержать одну строку. Например:
    <pre>
    test=# SELECT 2+2 AS result;
    </pre>
    <v-img src="@/assets/13.png"></v-img>

    Обычно при выборке данных требуется получить не все строки, а только те, которые удовлетворят какому-либо условию. Такое условие фильтрации записывается во фразе WHERE:
    <pre>
    test=# SELECT * FROM courses WHERE hours > 45;
    </pre>
    <v-img src="@/assets/14.png"></v-img>

    Условие должно иметь логический тип. Например, оно может содержать отношения =, <> (или !=), >, >=, <=; может объединять более простые условия с помощью логических операций AND, OR, NOT и круглых скобок — как в обычных языках программирования. 
    Тонкий момент представляет собой неопределенное значение NULL. В результирующую таблицу попадают только те строки, для которых условие фильтрации истинно; если же значение ложно или не определено, строка отбрасывается. Учтите:
    <ul>
        <li>

            результат сравнения чего-либо с неопределенным значением не определен; 
        </li>
        <li>

            результат логических операций с неопределенным значением, как правило, не определен (исключения: true OR NULL = true, false AND NULL = false); 
        </li>
        <li>

            для проверки определенности значения используются специальные отношения IS NULL (IS NOT NULL) и IS DISTINCT FROM (IS NOT DISTINCT FROM), а также бывает удобно воспользоваться функцией coalesce.
        </li>
    </ul>
</p>
<p>
    <span class="bold-header">
        
        Соединения
    </span>
    Грамотно спроектированная реляционная база данных не содержит избыточных данных. Например, таблица экзаменов не должна содержать имя студента, потому что его можно найти в другой таблице по номеру студенческого билета. 
    Поэтому для получения всех необходимых значений в запросе часто приходится соединять данные из нескольких таблиц, перечисляя их имена во фразе FROM:
    <pre>
    test=# SELECT * FROM courses, exams;
    </pre>
    <v-img src="@/assets/15.png"></v-img>
    То, что у нас получилось, называется прямым или декартовым произведением таблиц — к каждой строке одной таблицы добавляется каждая строка другой. 
    Как правило, более полезный и содержательный результат можно получить, указав во фразе WHERE условие соединения. Получим оценки по всем дисциплинам, сопоставляя курсы с теми экзаменами, которые проводились именно по данному курсу:
    <pre>    
    test=# SELECT courses.title, exams.s_id, exams.score
    FROM courses, exams
    WHERE courses.c_no = exams.c_no;
    </pre>
    <v-img src="@/assets/16.png"></v-img>
    Запросы можно формулировать и в другом виде, указывая соединения с помощью ключевого слова JOIN. Выведем студентов и их оценки по курсу «Сети ЭВМ»:
    <pre>
    test=# SELECT students.name, exams.score
    FROM students
    JOIN exams
    ON students.s_id = exams.s_id
    AND exams.c_no = 'CS305';
    </pre>
    <v-img src="@/assets/17.png"></v-img>

    С точки зрения СУБД обе формы эквивалентны, так что можно использовать тот способ, который представляется более наглядным. 
    Этот пример показывает, что в результат не включаются строки исходной таблицы, для которых не нашлось пары в другой таблице: хотя условие наложено на дисциплины, но при этом исключаются и студенты, которые не сдавали экзамен по данной дисциплине. Чтобы в выборку попали все студенты, надо использовать внешнее соединение:
    <pre>
    test=# SELECT students.name, exams.score
    FROM students
    LEFT JOIN exams
    ON students.s_id = exams.s_id
    AND exams.c_no = 'CS305';
    </pre>
    <v-img src="@/assets/18.png"></v-img>

    В этом примере в результат добавляются строки из левой таблицы (поэтому операция называется LEFT JOIN), для которых не нашлось пары в правой. При этом для столбцов правой таблицы возвращаются неопределенные значения.
     Условия во фразе WHERE применяются к уже готовому результату соединений, поэтому, если вынести ограничение на дисциплины из условия соединения, Нина не попадет в выборку — ведь для нее exams.c_no не определен:
    <pre>
    test=# SELECT students.name, exams.score
    FROM students
    LEFT JOIN exams ON students.s_id = exams.s_id
    WHERE exams.c_no = 'CS305';	
    </pre>
    <v-img src="@/assets/19.png"></v-img>
    Не стоит опасаться соединений. Это обычная и естественная для реляционных СУБД операция, и у PostgreSQL имеется целый арсенал эффективных механизмов для ее выполнения. Не соединяйте данные в приложении, доверьте эту работу серверу баз данных — он прекрасно с ней справляется.
</p>
<p>
    <span class="bold-header">
        
        Подзапросы
    </span>
    
    Оператор SELECT формирует таблицу, которая (как мы уже видели) может быть выведена в качестве результата, а может быть использована в другой конструкции языка SQL в любом месте, где по смыслу может находиться таблица. Такая вложенная команда SELECT, заключенная в круглые скобки, называется подзапросом. 
    Если подзапрос возвращает ровно одну строку и ровно один столбец, его можно использовать как обычное скалярное выражение:
    <pre>
    test=# SELECT name,
    (SELECT score
    FROM exams
    WHERE exams.s_id = students.s_id
    AND exams.c_no = 'CS305')
    FROM students;
    </pre>
    <v-img src="@/assets/20.png"></v-img>
    
    Если скалярный подзапрос, использованный в списке выражений SELECT, не содержит ни одной строки, возвращается неопределенное значение (как в последней строке результата примера). Поэтому скалярные подзапросы можно раскрыть, заменив их на соединение, но обязательно внешнее.
    Скалярные подзапросы можно также использовать в условиях фильтрации. Получим все экзамены, которые сдавали студенты, поступившие после 2014 года:
    <pre>
    test=# SELECT *
    FROM exams
    WHERE (SELECT start_year
    FROM students
    WHERE students.s_id = exams.s_id) > 2014;
    </pre>
    <v-img src="@/assets/21.png"></v-img>
    
    В SQL можно формулировать условия и на подзапросы, возвращающие произвольное количество строк. Для этого существует несколько конструкций, одна из которых — отношение IN — проверяет, содержится ли значение в таблице, возвращаемой подзапросом. 
    Выведем студентов, получивших какие-нибудь оценки по указанному курсу:
    <pre>
        test=# SELECT name, start_year
        FROM students
        WHERE s_id IN (SELECT s_id
        FROM exams
        WHERE c_no = 'CS305');
    </pre>
    <v-img src="@/assets/22.png"></v-img>

    Отношение NOT IN возвращает противоположный результат. Например, список студентов, не получивших ни одной отличной оценки:
    <pre>
    test=# SELECT name, start_year
    FROM students
    WHERE s_id NOT IN
    (SELECT s_id FROM exams WHERE score = 5);
</pre>
Обратите внимание, что такой запрос вернет и всех студентов, не получивших вообще ни одной оценки. 
Еще одна возможность — использовать предикат EXISTS, проверяющий, что подзапрос возвратил хотя бы одну строку. С его помощью можно записать предыдущий запрос в другом виде:
<pre>
    test=# SELECT name, start_year
    FROM students
    WHERE NOT EXISTS (SELECT s_id
    FROM exams
    WHERE exams.s_id = students.s_id
    AND score = 5);
</pre>
<v-img src="@/assets/23.png"></v-img>


В примерах выше мы уточняли имена столбцов названиями таблиц, чтобы избежать неоднозначности. Иногда этого недостаточно. Например, в запросе одна и та же таблица может участвовать два раза, или вместо таблицы в предложении FROM мы можем использовать безымянный подзапрос. В этих случаях после подзапроса можно указать произвольное имя, которое называется псевдонимом (alias). Псевдонимы можно использовать и для обычных таблиц. 
Выведем имена студентов и их оценки по предмету «Базы данных»:
<pre>
    test=# SELECT s.name, ce.score
    FROM students s
    JOIN (SELECT exams.*
    FROM courses, exams
    WHERE courses.c_no = exams.c_no
    AND courses.title = 'Базы данных') ce
    ON s.s_id = ce.s_id;
</pre>
<v-img src="@/assets/24.png"></v-img>

Здесь s — псевдоним таблицы, а ce — псевдоним подзапроса. Псевдонимы обычно выбирают так, чтобы они были короткими, но оставались понятными.
Тот же запрос можно записать и без подзапросов, например так:
<pre>
    test=# SELECT s.name, e.score
    FROM students s, courses c, exams e
    WHERE c.c_no = e.c_no
    AND c.title = 'Базы данных'
    AND s.s_id = e.s_id;
</pre>
</p>
<p>
    <span class="bold-header">
        
        Сортировка
    </span>

    Как уже говорилось, данные в таблицах не упорядочены, но часто бывает важно получить строки результата в строго определенном порядке. Для этого используется предложение ORDER BY со списком выражений, по которым надо выполнить сортировку. После каждого выражения (ключа сортировки) можно указать направление: ASC — по возрастанию (этот порядок используется по умолчанию) или DESC — по убыванию.
    <pre>
    test=# SELECT *
    FROM exams
    ORDER BY score, s_id, c_no DESC;
    </pre>
    <v-img src="@/assets/25.png"></v-img>
    Здесь строки упорядочены сначала по возрастанию оценки, для совпадающих оценок — по возрастанию номера студенческого билета, а при совпадении первых двух ключей — по убыванию номера курса. 
    Операцию сортировки имеет смысл выполнять в конце запроса непосредственно перед получением результата; в подзапросах она обычно бессмысленна.
</p>
<p>
    <span class="bold-header">
        
        Группировка
    </span>

    При группировке в одной строке результата размещается значение, вычисленное на основании данных нескольких строк исходных таблиц. Вместе с группировкой используют агрегатные функции. Например, выведем общее количество проведенных экзаменов, количество сдававших их студентов и средний балл:
    <pre>
    test=# SELECT count(*), count(DISTINCT s_id),
    avg(score)
    FROM exams;
    </pre>
    <v-img src="@/assets/26.png"></v-img>
    Аналогичную информацию можно получить в разбивке по номерам курсов с помощью предложения GROUP BY, в котором указываются ключи группировки:
    <pre>
    test=# SELECT c_no, count(*),
    count(DISTINCT s_id), avg(score)
    FROM exams
    GROUP BY c_no;
    </pre>
    <v-img src="@/assets/27.png"></v-img>
    В запросах, использующих группировку, может возникнуть необходимость отфильтровать строки на основании результатов агрегирования. Такие условия можно задать в предложении HAVING. Отличие от WHERE состоит в том, что условия WHERE применяются до группировки (в них можно использовать столбцы исходных таблиц), а условия HAVING — после группировки (и в них можно также использовать столбцы таблицы-результата). 
    Выберем имена студентов, получивших более одной пятерки по любому предмету:
    <pre>
    test=# SELECT students.name
    FROM students, exams
    WHERE students.s_id = exams.s_id AND exams.score = 5
    GROUP BY students.name
    HAVING count(*) > 1;
    </pre>
    <v-img src="@/assets/28.png"></v-img>
</p>
<p>
    <span class="bold-header">
        
        Изменение и удаление данных
    </span>
    
    Изменение данных в таблице выполняет оператор UPDATE, в котором указываются новые значения полей для строк, определяемых предложением WHERE (таким же, как в операторе SELECT). 
    Например, увеличим число лекционных часов для курса «Базы данных» в два раза:
    <pre>
    test=# UPDATE courses
    SET hours = hours * 2
    WHERE c_no = 'CS301';
    UPDATE 1
    </pre>
    Оператор DELETE удаляет из указанной таблицы строки, определяемые все тем же предложением WHERE:
    <pre>
    test=# DELETE FROM exams WHERE score < 5;
    DELETE 1
    </pre>
</p>
<p>
    <span class="bold-header">
        
        Транзакции	
    </span>
    Давайте немного расширим нашу схему данных и распределим студентов по группам. При этом потребуем, чтобы у каждой группы в обязательном порядке был староста. Для этого создадим таблицу групп:
    <pre>
    test=# CREATE TABLE groups(
    g_no text PRIMARY KEY,
    monitor integer NOT NULL REFERENCES students(s_id)
    );
    CREATE TABLE
    </pre>
    Здесь мы использовали ограничение целостности NOT NULL, которое запрещает неопределенные значения. 
    Теперь в таблице студентов нам необходим еще один столбец — номер группы, — о котором мы не подумали сразу. К счастью, в уже существующую таблицу можно добавить новый столбец:
    <pre>
    test=# ALTER TABLE students
    ADD g_no text REFERENCES groups(g_no);
    ALTER TABLE
    </pre>
    С помощью команды psql всегда можно посмотреть, какие столбцы определены в таблице: 
    <pre>
    test=# \d students
    </pre>
    <v-img src="@/assets/29.png"></v-img>
    
    Создадим теперь группу «A-101» и поместим в нее всех студентов, а старостой сделаем Анну. 
    Тут возникает затруднение. С одной стороны, мы не можем создать группу, не указав старосту. А с другой, как мы можем назначить Анну старостой, если она еще не входит в группу? Это привело бы к появлению в базе данных логически некорректных, несогласованных данных. 
    Мы столкнулись с тем, что две операции надо совершить одновременно, потому что ни одна из них не имеет смысла без другой. Такие операции, составляющие логически неделимую единицу работы, называются транзакцией. 
    Начнем транзакцию:
    <pre>
    test=# BEGIN;
    BEGIN
    </pre>
    Затем добавим группу вместе со старостой. Поскольку мы не помним наизусть номер студенческого билета Анны, выполним запрос прямо в команде добавления строк:
    <pre>
    test=*# INSERT INTO groups(g_no, monitor)
    SELECT 'A-101', s_id
    FROM students
    WHERE name = 'Анна';
    INSERT 0 1
    </pre>

    «Звездочка» в приглашении напоминает о незавершенной транзакции. 
    Откройте теперь новое окно терминала и запустите еще один процесс psql: это будет сеанс, работающий параллельно с первым. Чтобы не запутаться, команды второго сеанса мы будем показывать с отступом. 
    Увидит ли второй сеанс сделанные изменения?
    <pre>
    postgres=# \c test
    You are now connected to database "test" as user
    "postgres".
    test=# SELECT * FROM groups;
    </pre>
    <v-img src="@/assets/30.png"></v-img>
    
    Нет, не увидит, ведь транзакция еще не завершена. 
    Теперь переведем всех студентов в созданную группу:
    <pre>
    test=*# UPDATE students SET g_no = 'A-101';
    UPDATE 3
    </pre>
    И снова второй сеанс видит согласованные данные, актуальные на начало еще не оконченной транзакции:
    <pre>
    test=# SELECT * FROM students;
    </pre>
    <v-img src="@/assets/31.png"></v-img>
    А теперь завершим транзакцию, зафиксировав все сделанные изменения:
    <pre>
    test=*# COMMIT;
    COMMIT
    </pre>
    И только в этот момент второму сеансу становятся доступны все изменения, сделанные в транзакции, как будто они появились одномоментно:
    <pre>
    test=# SELECT * FROM groups;
    </pre>
    <pre>
        test=# SELECT * FROM students;
    </pre>
    <v-img src="@/assets/32.png"></v-img>
    
    СУБД дает несколько очень важных гарантий. Во-первых, любая транзакция либо выполняется целиком (как в нашем примере), либо не выполняется совсем. Если бы в одной из команд произошла ошибка, или мы сами прервали бы транзакцию командой ROLLBACK, то база данных осталась бы в том состоянии, в котором она была до команды BEGIN. Это свойство называется атомарностью. 
    Во-вторых, когда фиксируются изменения транзакции, все ограничения целостности должны быть выполнены, иначе транзакция прерывается. В начале работы транзакции данные находятся в согласованном состоянии, и в конце своей работы транзакция оставляет их согласованными; это свойство так и называется — согласованность. 
    В-третьих, как мы убедились на примере, другие пользователи никогда не увидят несогласованные данные, которые транзакция еще не зафиксировала. Это свойство называется изоляцией; за счет его соблюдения СУБД способна параллельно обслуживать много сеансов, не жертвуя корректностью данных. Особенностью PostgreSQL является очень эффективная реализация изоляции: несколько сеансов могут одновременно читать и изменять данные, не блокируя друг друга. Блокировка возникает только при одновременном изменении одной и той же строки двумя разными процессами. 
    И в-четвертых, гарантируется долговечность: зафиксированные данные не пропадут даже в случае сбоя (конечно, при правильных настройках и регулярном выполнении резервного копирования). 
    Это крайне полезные свойства, без которых невозможно представить себе реляционную систему управления базами данных.
</p>
<p>
    <span class="bold-header">
        Контрольные вопросы
        
    </span>
    <ol>
        <li>

            Какая команда используется для массовой загрузки данных из внешнего источника?
        </li>
        <li>
            Какие существуют тонкости при логических операциях с неопределенным значением?

        </li>
        <li>
            Какая существует разница между внутренними и внешними соединениями?

        </li>
        <li>

            Что означает «Звездочка» в приглашении командной строки psql?
        </li>
        <li>

            Какие свойства ACID верны для PostgreSQL?
        </li>
    </ol>
</p>
<p>
    <span class="bold-header">
        Упражнения для самостоятельной работы
        
    </span>
    <ol>
        <li>
            Разработать базу данных для производителя и поставщика мороженного. Пример базы данных на изображении ниже. Заполнить полученную базу данными. При создании таблиц применить возможность использования Constraint’ов. Пример: проверка корректности номера компании-заказчика. При создании таблиц воспользоваться возможность создания собственных типов данных. Пример: множественный тип статусов заказа

            
            Решение: 
            <pre>
    /*
    Таблица ингридиентов
    Id - айди ингридиента
    Name - имя ингридиента. по дефолту "unknown"
    Price - стоймость ингридента. по дефолту 0
    Info - информация об игридиенте. по дефолту '-'
    */
    Create table Ingredient
    ( Id serial primary key,
        Name varchar(45) UNIQUE default 'unknown',
        Price numeric(100, 2) default 0,
        Info text default '-'
    );
    
    /*
    Таблица продуктов
    Id - айди продукта
    Name - имя продукта. Должно быть уникальным. по дефолту "unknown"
    Price - стоймость продукта. по дефолту 0
    Info - информация об игридиенте. по дефолту '-'
    */
    Create table Product
    ( Id serial primary key,
        Name varchar(45) UNIQUE default 'unknown',
        Price numeric(100, 2) default 0,
        Info text  default '-'
    );
    
    /*
    Таблица ингридиентов в продукте
    IdProduct - айди продукта. Внешний ключ
    IdIngredient - айди ингридиента. Внешний ключ
    IngAmount - количество ингридиентов. по дефолту 1
    */
    Create table ProductHasIngr
    ( IdProduct integer,
        IdIngredient integer,
        IngAmount integer default 1,
        
        Foreign key (idProduct) references Product(Id) on delete cascade,
        Foreign key (IdIngredient) references Ingredient(Id) on delete cascade
    );
/*
Таблица Покупателей
Id - айди покупателя
Name - имя покупателя. Должно быть уникальным. по дефолту "unknown"
Phone - телефон покупателя

CustomerPhone - ограничение типа телефонов, т.е. определяется соотвествее двум маскам
*/
Create table Customer
( Id serial primary key,
    Name varchar(45) UNIQUE default 'unknown',
    Phone varchar(20),
    
    Constraint CustomerPhone check( Phone Similar to '[0-9]{11}' or Phone Similar to '\+[0-9]\([0-9]{3}\)[0-9]{3}-[0-9]{2}-[0-9]{2}')
    );
    
    /*
    Тип статусов заказа
    not in stock - нет в наличии (комплектуется)
    in stock - в наличии (укомплектованно)
    shipped - отправлено покупателю
    returned to warehouse - отправлено на склад для докомплектации
    shipment cancellation - отмена отправки покупателю
    */
    Create type OrderStatus as enum('not in stock', 'in stock', 'shipped', 'returned to warehouse', 'shipment cancellation');
    
    /*
    Таблица заказов
    Id - айди заказа
    IdCustomer - айди покупателя. Внешний ключ
    Date - дата поступления заказа. По дефолту нынешняя дата
    Status - статус заказа. 
    Price - итоговая стоймость заказа
    */
    Create table Orders
    ( Id serial primary key,
      IdCustomer integer,
      Date date default NOW(),
      Status OrderStatus default 'not in stock',
      Price numeric(100, 2) default 0,
      
      Foreign key (IdCustomer) references Customer(Id) on delete cascade
    );
    
    /*
    Таблица продуктов в заказе
    IdOrder - айди заказа. Внешний ключ
    IdProduct - айди продукта. Внешний ключ
    ProductAmount - количество продукта. По дефолту 1
    */
    Create table OrdersHaveProduct
    ( IdOrder integer,
      IdProduct integer,
      ProductAmount integer default 1,
     
      Foreign key (idProduct) references Product(Id) on delete cascade,
      Foreign key (IdOrder) references Orders(Id) on delete cascade
     
    );
            </pre>
            
        </li>
        <li>

            Создать хранимые процедуры для добавления и обновления данных в таблицах по примеру: 
            <pre>
    /*
    Добавить ингридиент
    IngName - имя ингридиента
    IngPrice - стоимость ингридиента
    IngInfo - информация об ингридиенте
    */
    Create or Replace Procedure IngInsert(IngName varchar(45), IngPrice decimal(100,2), IngInfo varchar(45) default '')
    LANGUAGE sql
    as $$
    insert into Ingredient(Name, Price, Info)
        values (IngName, IngPrice, IngInfo);
    $$;

    /*
    Обновить ингридиент
    IngId - айди игридиента
    IngName - имя ингридиента
    IngPrice - стоимость ингридиента
    IngInfo - информация обингридиента
    */
    Create or Replace Procedure IngUpdate(IngId int, IngName varchar(45), IngPrice decimal(100,2), IngInfo varchar(45) default '')
    LANGUAGE sql
    as $$
    update Ingredient set 
        Name = IngName, 
        Price = IngPrice, 
        Info = IngInfo
    where IngId = id
    $$;  
            </pre>
        </li>
        <li>

            Для каждого продукта необходимо узнать магазин, в который было отправлено наибольшее количество заказов с ним в текущем месяце, а также предыдущем месяце
        </li>
        <li>
            Для каждого магазина узнать среднюю сумму заказов в каждом месяце.

        </li>
    </ol>
</p>
    </v-card>

</template>

<script>
import Navigation from '@/components/Navigation.vue'

export default {
    name: 'Section2',
    components: {
        Navigation
    }
}
</script>