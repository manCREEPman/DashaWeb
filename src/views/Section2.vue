<template>
    <v-card
    class="px-5">
    <v-card-title>
            Конфигурация web-приложения
        </v-card-title>
        <p>
            <span class="bold-header">
                
                Конфигурация приложения
            </span>
            <ul>
                <li>
                    DEBUG	Включить/выключить режим отладки.

                </li>
                <li>
                    TESTING	Включить/выключить режим тестирования.
                </li>
                <li>
                    PROPAGATE_EXCEPTIONS	Явное включение или отключение исключений. Если не задано или явным образом задано значение None, то подразумевается истина, если истиной является TESTING или DEBUG.
                </li>
                <li>
                    PRESERVE_CONTEXT_ON_EXCEPTION	По умолчанию в режиме отладки при возникновении исключения контекст запроса не извлекается из стека, позволяя отладчику анализировать данные. Такое поведение можно отключить с помощью этого параметра. Также можно воспользоваться этим параметром для его принудительного включения, если это может помочь в отладке приложений в эксплуатации (однако, это не рекомендуется).

                </li>
                <li>
                    SECRET_KEY	Секретный ключ.
                </li>
                <li>
                    SESSION_COOKIE_NAME	Имя переменной (cookie) браузера для хранения сеанса.

                </li>
                <li>
                    SESSION_COOKIE_DOMAIN	Домен переменной браузера, используемой для хранения сеанса. Если не задан, переменная браузера будет действительной для всех поддоменов SERVER_NAME.

                </li>
                <li>
                    SESSION_COOKIE_PATH	Путь к переменной браузера, используемой для хранения сеанса. Если не задан, переменная браузера будет действительной для всех APPLICATION_ROOT, если не задано значение '/'.

                </li>
                <li>
                    SESSION_COOKIE_HTTPONLY	Указывает, должен ли у переменной браузера устанавливаться флаг httponly (что защищает переменную от доступа со стороны скриптов, работающих внутри браузера - прим. перев.). По умолчанию - True.

                </li>
                <li>
                    SESSION_COOKIE_SECURE	Указывает, должен ли у переменной браузера устанавливаться флаг secure (что позволяет передавать переменную только по защищённому протоколу HTTPS - прим. перев.). По умолчанию - False.

                </li>
                <li>
                    PERMANENT_SESSION_LIFETIME	Непрерывное время жизни сеанса, как объект datetime.timedelta. Начиная с Flask 0.8 этот параметр может быть задан в виде целого числа с количеством секунд.

                </li>
                <li>
                    SESSION_REFRESH_EACH_REQUEST	Этот флаг контролирует, как будут обновляться постоянные сессии. Если установлен в True (по умолчанию), cookies будут обновляться при каждом запросе, что автоматически подтолкнёт вперёд окончание их срока жизни. Если установлен в False, заголовок set-cookie посылается только в случае внесения изменений в сессию. Не влияет на не постоянные сессии.

                </li>
                <li>
                    USE_X_SENDFILE	Включить/отключить x-sendfile. (При использовании этой возможности представление может вернуть специально сформированный ответ со ссылкой на статический файл. Получив такой ответ от представления, веб-сервер отдаёт клиенту вместо ответа представления сам статический файл, найдя его по ссылке в локальной файловой системе. Это позволяет перенести нагрузку по отдаче больших файлов на веб-сервер, если перед отдачей файла представление должно решить, можно ли отдавать этот файл клиенту и какой именно файл нужно отдать по этой ссылке - прим. перев.)

                </li>
                <li>
                    LOGGER_NAME	Имя средства журналирования.

                </li>
                <li>
                    SERVER_NAME	Имя и номер порта сервера. Необходимо для поддержки поддоменов (например: 'myapp.dev:5000'). Отметим, что localhost не поддерживает поддомены, поэтому установка параметра в значение “localhost” не поможет. Настройка SERVER_NAME также по умолчанию включает генерацию URL’ов без контекста запроса, но с контекстом приложения.

                </li>
                <li>
                    APPLICATION_ROOT	Если приложение не занимает целый домен или поддомен, с помощью этого параметра можно задать путь к настроенному приложению. Значение этого параметра используется в качестве пути к переменной браузера для хранения сеанса. Если используются домены, значением этого параметра должно быть None.

                </li>
                <li>
                    MAX_CONTENT_LENGTH	Если задать значение в байтах, Flask будет отклонять входящие запросы, объём содержимого которых больше этого значения, возвращая код статуса 413.

                </li>
                <li>
                    SEND_FILE_MAX_AGE_DEFAULT:	По умолчанию задаёт время кэширования файла для использования совместно с send_static_file() (обработчик статических файлов по умолчанию) и send_file(), в секундах. Заменить это значение для каждого файла индивидуально можно с помощью обработчика get_send_file_max_age() Flask или Blueprint. По умолчанию - 43200 (12 часов).

                </li>
                <li>
                    TRAP_HTTP_EXCEPTIONS	Если True, Flask не выполняет обработчиков ошибок исключений HTTP, но вместо этого трактует исключение как любое другое и передаёт исключение выше. Этот параметр полезен для отладки сложных случаев, когда нужно найти, где именно произошло исключение HTTP.

                </li>
                <li>
                    TRAP_BAD_REQUEST_ERRORS	Внутренние структуры данных Werkzeug, работающие с данными запроса порождают ошибки с особым ключом, также являющимся исключением запроса. Также, многие операции могут неявно приводить к исключениям BadRequest в случае ошибок целостности. Поскольку для отладки важно знать, где именно произошла ошибка, этот флаг может использоваться для отладки в подобных случаях. Если этот параметр истинен (True), произойдёт обычная выдача результата трассировки.

                </li>
                <li>
                    PREFERRED_URL_SCHEME	Схема, которую нужно использовать для генерации URL’ов, если она не указана явно. По умолчанию - http.

                </li>
                <li>
                    JSON_AS_ASCII	По умолчанию Flask сериализует объекты к JSON, представленному в виде ASCII. Если False, Flask не будет кодировать в ASCII, а выводимые строки будут как есть, то есть в виде строк в формате unicode. Затем, json-ификация автоматически переведёт их к кодировке utf-8 для дальнейшей доставки для экземпляра.

                </li>
                <li>
                    JSON_SORT_KEYS	По умолчанию Flask сериализует объекты JSON таким способом, что ключи становятся упорядоченными. Это делается, чтобы гарантировать, что независимо от значения хэша словаря, возвращаемое значение будет таким, чтобы не замусоривать внешние HTTP- кэши. Вы можете переопределить поведение по умолчанию через изменение этой переменной. Это не рекомендовано, но может дать вам выигрыш в производительности ценой худшей кэшируемости данных.

                </li>
                <li>
                    JSONIFY_PRETTYPRINT_REGULAR	Если True (по умолчанию), ответы json-ификации будут распечатаны, если они не запрашивались объектом XMLHttpRequest (который контролируется заголовком X-Requested-With)

                </li>
                <li>
                    TEMPLATES_AUTO_RELOAD	Flask проверяет, был ли изменён шаблон каждый раз, когда он запрашивается, и перезагружает его в случае такой необходимости. Однако это происходит ценой увеличения дискового ввода-вывода, и может появиться жизненная необходимость отключить данную особенность путём установки этого ключа в False. Данная опция не оказывает влияния при работе в режиме отладки.

                </li>
            </ul>
        </p>

        <p>

            Сначала грузится конфигурация из модуля yourapplication.default_settings, а затем её значения заменяет содержимое файла, указанного в переменной окружения YOURAPPLICATION_SETTINGS. Эта переменная окружения может быть задана в Linux или OS X при помощи команды export оболочки перед запуском сервера:
            <pre>
    $ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg
    $ python run-app.py
        * Running on http://127.0.0.1:5000/
        * Restarting with reloader...

            </pre>
        </p>
        <p>
            В системах Windows воспользуйтесь встроенной командой set.

        </p>

<p>
    <span class="bold-header">

        Рекомендации по заданию конфигурации
    </span>
    Создайте ваше приложение внутри функции и зарегистрируйте в ней blueprint’ы. Таким образом вы можете создать несколько экземпляров вашего приложения с разными конфигурациями, что значительно упростит модульное тестирование. Вы можете воспользоваться функцией, чтобы передать в неё необходимую конфигурацию.
    Не пишите код, которому требуется конфигурация при импорте. Если ограничиться чтением конфигурации по запросу, возможно будет переконфигурировать объект позже.

</p>
<p>
    <span class="bold-header">

        Blueprint’ы во Flask 
</span>
Концепция blueprint’ов¶
Основная концепция blueprint’ов заключается в том, что они записывают операции для выполнения при регистрации в приложении. Flask связывает функции представлений с blueprint’ами при обработке запросов и генерировании URL’ов от одной конечной точки к другой.
Могут пригодиться в случае, если нужно:

<ul>
    <li>
        Разделить приложения на набор blueprint’ов. Они идеальны для больших приложений; проект должен создать объект приложения, инициализировав несколько расширений, и зарегистрировав набор blueprint’ов.

    </li>
    <li>
        Зарегистрировать blueprint в приложении по определённом префиксу URL и/или в поддомене. Параметры в префиксе URL или поддомене становятся обычными аргументами представлений (со значениями по умолчанию) для всех функций представлений в blueprint’е.

    </li>
    <li>
        Зарегистрировать blueprint несколько раз в приложении с разными правилами URL.

    </li>
    <li>
        Предоставить фильтры шаблонов, статический файлы, шаблоны и другие вспомогательные средства с помощью blueprint’ов. Blueprint не является реализацией приложения или функций представлений.

    </li>
    <li>
        Зарегистрировать blueprint в приложении в любом из этих случаев при инициализации расширения Flask.

    </li>
    <li>
        Blueprint во Flask не является подключаемым приложением, потому что это на самом деле не приложение – это набор операций, которые могут быть зарегистрированы в приложении, возможно даже не один раз. Почему бы не воспользоваться несколькими объектами приложений? Вы можете это сделать (обратитесь к разделу app-dispatch), но ваши приложения будут иметь раздельные файлы конфигурации и будут управляться слоем WSGI.

    </li>
    Вместо этого, blueprint’ы предоставляют разделение на уровне Flask, позволяя использовать общий файл конфигурации приложения и могут менять объект приложения необходимым образом при регистрации. Побочным эффектом будет невозможность отменить регистрацию blueprint’а, если приложение уже было создано, если только не уничтожить целиком весь объект приложения.

</ul>
</p>

<p>
    <span class="bold-header">
        Контрольные вопросы

    </span>
    <ol>
        <li>
            Какой параметр приложения отвечает за влключение/выключение режима отладки?

        </li>
        <li>
            	Какой параметр приложения нужен для задания секретного ключа? 

        </li>
        <li>
            Какой параметр приложения содержит путь к настроенному приложению Flask?

        </li>
        <li>
            	Что такое blueprint?

        </li>
        <li>
            Какие есть рекомендации по архитектуре приложения Flask?

        </li>
    </ol>
</p>

<p>
    <span class="bold-header">
        Упражнения для самостоятельной работы

    </span>
    <ol>
        <li>
Создать параметризированные представления и зарегистрировать их в отдельном blueprint-е.
<span class="bold-header">
    Решение

</span>
<br>
Создадим в корне приложения файл pages_blueprint.py следующего содержания:
<pre>
from flask import Blueprint, render_template

page_views = Blueprint('pages_views', __name__, template_folder='templates', static_folder='static')

@page_views.route('/user/username', methods=['POST', 'GET'])
def user_view(username):
    context = {'string': f'Пользователь {username}' }
    return render_template('text_template.html', context=context)

@page_views.route('/page/int:page_id')
def page_view(page_id):
    context = {'string': f'Страница {page_id}' }
    return render_template('text_template.html', context=context)
</pre>
<br>
В главном файле приложения (server.py) напишем следующий код:
<pre>
    
from flask import Flask
from pages_blueprint import page_views

app = Flask(__name__)
app.register_blueprint(page_views)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=1234)
</pre>
        
</li>
        <li>

Создать и зарегистрировать 2 blueprint-а, а также подключить их к основному приложению.

        </li>
        <li>
Создать blueprint, который полностью отвечает за получение данных.
        </li>
    </ol>
</p>

    </v-card>

</template>

<script>
import Navigation from '@/components/Navigation.vue'

export default {
    name: 'Section2',
    components: {
        Navigation
    }
}
</script>