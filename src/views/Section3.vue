<template>
    <v-card
    class="px-5">
    <v-card-title>

        Работа с демонстрационной базой данных. Оконные и агрегатные функции
    </v-card-title>
    <p>
        <span class="bold-header">
            Описание. Общая информация.
    </span>
    Чтобы двигаться дальше и учиться писать более сложные запросы, нам понадобится более серьезная база данных — не три таблицы, а целых восемь, — и наполнение ее правдоподобными данными. Схема базы данных, которую мы будем использовать, изображена в виде диаграммы «сущность-связи». 
    В качестве предметной области мы выбрали авиаперевозки: будем считать, что речь идет о нашей (пока еще несуществующей) авиакомпании. Тем, кто хотя бы раз летал на самолетах, эта область должна быть понятна; в любом случае мы сейчас все объясним.
    Основной сущностью является бронирование (bookings). В одно бронирование можно включить несколько пассажиров, каждому из которых выписывается отдельный билет (tickets). Как таковой пассажир не является отдельной сущностью: для простоты можно считать, что все пассажиры уникальны. 
    Каждый билет включает один или несколько перелетов (ticket_flights). Несколько перелетов могут включаться в билет в нескольких случаях:
    <ol>
        <li>
            Нет прямого рейса, соединяющего пункты отправления и назначения (полет с пересадками); 
        </li>
        <li>
            Взят билет «туда и обратно».
        </li>
    </ol>    
    В схеме данных нет жесткого ограничения, но предполагается, что все билеты в одном бронировании имеют одинаковый набор перелетов. 
    Каждый рейс (flights) следует из одного аэропорта (airports) в другой. Рейсы с одним номером имеют одинаковые пункты вылета и назначения, но будут отличаться датой отправления. 
    При регистрации на рейс пассажиру выдается посадочный талон (boarding_passes), в котором указано место в самолете. Пассажир может зарегистрироваться только на тот рейс, который есть у него в билете. Комбинация рейса и места в самолете должна быть уникальной, чтобы не допустить выдачу двух посадочных талонов на одно место. 
    Количество мест (seats) в самолете и их распределение по классам обслуживания зависит от конкретной модели самолета (aircrafts), выполняющего рейс. Предполагается, что у каждой модели — только одна компоновка салона.
    <v-img src="@/assets/35.png"></v-img>
    
    Схема данных не контролирует, что места в посадочных талонах соответствуют имеющимся в салоне.
    <hr>
    Бронирование: Намереваясь воспользоваться услугами нашей авиакомпании, пассажир заранее (book_date, максимум за месяц до рейса) бронирует необходимые билеты. Бронирование идентифицируется своим номером book_ref (шестизначная комбинация букв и цифр). Поле total_amount хранит общую стоимость включенных в бронирование перелетов всех пассажиров. 
    <hr>
    Билет имеет уникальный номер ticket_no, состоящий из 13 цифр. Билет содержит номер документа, который удостоверяет личность пассажира passenger_id, а также его фамилию и имя passenger_name и контактную информацию contact_data. Заметим, что ни идентификатор пассажира, ни его имя не являются постоянными (можно поменять паспорт, можно сменить фамилию). Поэтому однозначно найти все билеты одного и того же пассажира невозможно. Для простоты можно считать, что все пассажиры уникальны.
    <hr>
    Перелет соединяет билет с рейсом и идентифицируется двумя их номерами. Для каждого перелета указываются его стоимость amount и класс обслуживания fare_conditions. 
    <hr>
    Рейс: Естественный ключ таблицы рейсов состоит из двух полей — номера рейса flight_no и даты отправления scheduled_departure. Чтобы сделать внешние ключи на эту таблицу компактнее, в качестве первичного используется суррогатный ключ flight_id. Рейс всегда соединяет две точки — аэропорты вылета departure_airport и прибытия arrival_airport. Такое понятие, как «рейс с пересадками» отсутствует: если из одного аэропорта до другого нет прямого рейса, в билет просто включаются несколько необходимых рейсов. У каждого рейса есть запланированные дата и время вылета scheduled_departure и прибытия scheduled_arrival. Реальные время вылета actual_departure и прибытия actual_arrival могут отличаться: обычно не сильно, но иногда и на несколько часов, если рейс задержан.
    <hr>
    Аэропорт: Каждый аэропорт идентифицируется трехбуквенным кодом airport_code и имеет название airport_name. Название города city указывается как атрибут аэропорта; отдельной сущности для него не предусмотрено. Название можно использовать для того, чтобы определить аэропорты одного города. Также указываются координаты (долгота и широта) coordinates и часовой пояс timezone. 
    <hr>
    Посадочный талон: При регистрации на рейс, которая возможна за сутки до плановой даты отправления, пассажиру выдается посадочный талон. Он идентифицируется так же, как и перелет — номером билета и номером рейса. Посадочным талонам присваиваются последовательные номера boarding_no в порядке регистрации пассажиров на рейс (этот номер будет уникальным только в пределах данного рейса). В посадочном талоне указывается номер места seat_no. 
    <hr>
    Самолет: Каждая модель воздушного судна идентифицируется своим трехзначным кодом aircraft_code. Указывается также название модели model и максимальная дальность полета в километрах range. 
    <hr>
    Место: Места определяют схему салона каждой модели. Каждое место определяется своим номером seat_no и имеет закрепленный за ним класс обслуживания fare_conditions — Economy, Comfort или Business.
    <hr>
    Функция now. Демонстрационная база содержит временной «срез» данных — так, как будто в некоторый момент была сделана резервная копия реальной системы. Например, если некоторый рейс имеет статус Departed, это означает, что в момент резервного копирования самолет находился в воздухе. Позиция «среза» сохранена в функции bookings.now. Ей можно пользоваться в запросах там, где в обычной жизни использовалась бы функция now.
</p>
<p>
    <span class="bold-header">
        
        Установка
    </span>
    База данных доступна в трех версиях, которые отличаются только объемом данных:  
<ul>
    <li>

        edu.postgrespro.ru/demo-small.zip — небольшая, данные по полетам за один месяц (файл 21 МБ, размер БД 280 МБ), 
    </li>
    <li>
        edu.postgrespro.ru/demo-medium.zip — средняя, данные по полетам за три месяца (файл 62 МБ, размер БД 702 МБ), 

    </li>
    <li>
        edu.postgrespro.ru/demo-big.zip — большая, данные по полетам за один год (файл 232 МБ, размер БД 2638 МБ). 

    </li>
</ul>
</p>
<p>

    Небольшая база годится для того, чтобы тренироваться писать запросы, и при этом не займет много места на диске. Если же вы хотите погрузиться в вопросы оптимизации, выберите большую базу, чтобы сразу понять, как ведут себя запросы на больших объемах данных. 
    Файлы содержат логическую резервную копию базы demo, созданную утилитой pg_dump. Имейте в виду, что если у вас уже есть база данных с именем demo, она будет удалена и создана заново при восстановлении из резервной копии.
    Владельцем базы demo станет тот пользователь СУБД, под которым выполнялось восстановление. 
    Чтобы установить демонстрационную базу данных в операционной системе Linux, скачайте один из файлов, предварительно переключившись на пользователя postgres. Например, для базы небольшого размера это можно сделать следующим образом:
    <pre>
    $ sudo su - postgres
    $ wget https://edu.postgrespro.ru/demo-small.zip
    </pre>
    Затем выполните команду:
    <pre>
    $ zcat demo-small.zip | psql
    </pre>
    В операционной системе Windows любым веб-браузером скачайте с сайта файл edu.postgrespro.ru/demo-small.zip, после чего дважды кликните на нем, чтобы открыть архив, и затем скопируйте файл demo-small-20170815.sql в каталог C:\Program Files\PostgreSQL\13. 
    
Программа pgAdmin (о которой пойдет речь на с. 115) не позволяет восстановить базу данных из такой резервной копии. Поэтому запустите psql (ярлык «SQL Shell (psql)») и выполните команду:
==><==
postgres# \i demo-small-20170815.sql

Если файл не будет найден, проверьте у ярлыка свойство «Start in» («Рабочая папка») — файл должен находиться именно в этом каталоге.

Примеры запросов
Теперь, когда установка выполнена, запустите psql и подключитесь к демонстрационной базе:
postgres=# \c demo
You are now connected to database "demo" as user
"postgres".

Все интересующие нас объекты находятся в схеме bookings. При подключении к базе данных эта схема используется автоматически, так что явно ее указывать не нужно:

demo=# SELECT * FROM aircrafts;

 

Однако для функции bookings.now указывать схему необходимо, чтобы отличать ее от стандартной функции now:

demo=# SELECT bookings.now();

 

Как вы уже заметили, названия самолетов выводятся по-русски. Так же обстоит дело и с названиями аэропортов и городов:

demo=# SELECT airport_code, city
FROM airports LIMIT 5;

 

Если вы предпочитаете английские названия, установите параметр bookings.lang в значение en:
demo=# ALTER DATABASE demo SET bookings.lang = en;
ALTER DATABASE

Настройка действует только для новых сеансов, поэтому нужно подключиться заново.
demo=# \c
You are now connected to database "demo" as user "postgres".
demo=# SELECT airport_code, city
FROM airports LIMIT 5;
 
Задача. Кто летел позавчера рейсом Москва (SVO) — Новосибирск (OVB) на месте 1A, и когда он забронировал свой билет?
Решение. «Позавчера» отсчитывается от booking.now, а не от текущей даты.
SELECT t.passenger_name,
b.book_date
FROM bookings b
JOIN tickets t
ON t.book_ref = b.book_ref
JOIN boarding_passes bp
ON bp.ticket_no = t.ticket_no
JOIN flights f
ON f.flight_id = bp.flight_id
WHERE f.departure_airport = 'SVO'
AND f.arrival_airport = 'OVB'
AND f.scheduled_departure::date =
bookings.now()::date - INTERVAL '2 day'
AND bp.seat_no = '1A';



Оконные и агрегатные функции
Агрегатные функции вычисляют одно значение над некоторым набором строк. В PostgreSQL имеются следующие агрегатные функции:
•	AVG: находит среднее значение. Входной параметр должен представлять один из следующих типов: smallint, int, bigint, real, double precision, numeric, interval. Для целочисленнных параметров результатом будет значение типа numeric, для параметров, которые представляют число с плавающей точкой, - значение типа double precision.
•	BIT_AND: выполняет операцию побитового умножения (операции логического И) для чисел следующих типов: smallint, int, bigint, bit. Если параметр содержит значение NULL, то возвращается NULL.
•	BIT_OR: выполняет операцию побитового сложения (операции логического ИЛИ) для чисел следующих типов: smallint, int, bigint, bit. Если параметр содержит значение NULL, то возвращается NULL.
•	BOOL_AND: выполняет операцию логического умножения для значений типа bool. Если входные все значения равны true, то возвращается true, иначе возвращается false.
•	BOOL_OR: выполняет операцию логического сложения для значений типа bool. Если входные хотя бы одно из значений равно true, то возвращается true, иначе возвращается false.
•	COUNT(*): находит количество строк в запросе
•	COUNT(expression): находит количество строк в запросе, для которых expression не содержит значение NULL.
•	SUM: находит сумму значений
•	MIN: находит наименьшее значение
•	MAX: находит наибольшее значение
•	STRING_AGG(expression, delimiter): соединяет с помощью delimiter все текстовые значения из expression в одну строку.
В качестве параметра все агрегатные функции принимают выражение, которое представляет критерий для определения значений. Зачастую, в качестве выражения выступает название столбца, над значениями которого надо проводить вычисления.
Если в наборе нет строк, то все агрегатные функции за исключением COUNT(*) возвращают значение NULL.
Оконные функции не изменяют выборку, а только добавляют некоторую дополнительную информацию о ней. Т.е. для простоты понимания можно считать, что postgres сначала выполняет весь запрос (кроме сортировки и limit), а потом только просчитывает оконные выражения.
Синтаксис примерно такой:

функция OVER окно

Окно — это некоторое выражение, описывающее набор строк, которые будет обрабатывать функция и порядок этой обработки.
Причем окно, может быть, просто задано пустыми скобками (), т.е. окном являются все строки результата запроса.
Запрос ниже позволяет добавить нумерацию строк

SELECT
    airport_code,
    airport_name,
    city,
    row_number() OVER ()  AS num
FROM Airports;

В оконное выражение можно добавить ORDER BY, тогда можно изменить порядок обработки. В оконное выражение можно добавить слово PARTITION BY [expression],
например row_number() OVER (PARTITION BY city), тогда подсчет будет идти в каждой группе отдельно:

SELECT
    airport_code,
    airport_name,
    city,
    row_number() OVER (PARTITION BY city ORDER BY coordinates DESC) AS coords_in_city
FROM Airports;

Если не указывать партицию, то партицией является весь запрос.
В качестве функции можно использовать, так сказать, истинные оконные функции из мануала — это row_number(), rank(), lead() и т.д., а можно использовать функции-агрегаты, такие как: sum(), count() и т.д. Так вот, это важно, агрегатные функции работают слегка по-другому: если не задан ORDER BY в окне, идет подсчет по всей партиции один раз, и результат пишется во все строки (одинаков для всех строк партиции). Если же ORDER BY задан, то подсчет в каждой строке идет от начала партиции до этой строки.
Оконные функции можно использовать сразу по несколько штук, они друг другу ничуть не мешают.

Если у вас много одинаковых выражений после OVER, то можно дать им имя и вынести отдельно с ключевым словом WINDOW, чтобы избежать дублирования кода.

SELECT
    count(airport_code) OVER w,
    max(coordinates) OVER w
FROM Airports
WINDOW w AS (PARTITION BY city);


Результат работы оконной функции невозможно отфильтровать в запросе с помощью WHERE, потому что оконные функции выполняются после всей фильтрации и группировки, т.е. с тем, что получилось.



Контрольные вопросы
1.	Чем отличаются COUNT(*) и COUNT(expression)?
2.	Для чего может быть полезна агрегатная функция STRING_AGG (expression, delimiter)?
3.	Из каких частей состоят оконные функции?
4.	Можно ли сортировать значения внутри оконных функций по убыванию?
5.	В какой последовательности будет происходить сортировка внутри оконной функции и сортировка общего запроса?

Упражнения для самостоятельной работы
1.	Сколько мест осталось незанятыми вчера на рейсе PG0404?
Ответ. Задачу можно решить несколькими способами. Первый вариант использует конструкцию NOT EXISTS, чтобы определить места без посадочных талонов:

SELECT count(*)
FROM flights f
JOIN seats s
ON s.aircraft_code = f.aircraft_code
WHERE f.flight_no = 'PG0404'
AND f.scheduled_departure::date =
bookings.now()::date - INTERVAL '1 day'
AND NOT EXISTS (
SELECT NULL
FROM boarding_passes bp
WHERE bp.flight_id = f.flight_id
AND bp.seat_no = s.seat_no
);

Второй использует операцию вычитания множеств:

SELECT count(*)
FROM (
SELECT s.seat_no
FROM seats s
WHERE s.aircraft_code = (
SELECT aircraft_code
FROM flights
WHERE flight_no = 'PG0404'
AND scheduled_departure::date =
bookings.now()::date - INTERVAL '1 day'
)
EXCEPT
SELECT bp.seat_no
FROM boarding_passes bp
WHERE bp.flight_id = (
SELECT flight_id
FROM flights
WHERE flight_no = 'PG0404'
AND scheduled_departure::date =
bookings.now()::date - INTERVAL '1 day'
)
) t;

2.	На каких маршрутах произошли самые длительные задержки рейсов? Выведите список из десяти «лидирующих» рейсов.
3.	Какова минимальная и максимальная продолжительность полета для каждого из возможных рейсов из Москвы в Санкт-Петербург, и сколько раз вылет рейса был задержан больше, чем на час?
4.	Сколько человек бывает включено в одно бронирование?
</p>
 






    </v-card>
</template>

<script>
import Navigation from '@/components/Navigation.vue'

export default {
    name: 'Section3',
    components: {
        Navigation
    }
}
</script>